<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超高级知识图谱</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="src/web/css/style.css">
</head>
<body>
   <canvas id="particle-canvas"></canvas>
    <div id="sidebar">
        <h2 >Mind-of-Ai'lab by BH_Y</h2>
        <h3 src="D:\my-knowledge-graph\data\pdfs\2405.20441v4.pdf">welcom</h3>
        <ul id="pdf-list">
            </ul>
    </div>
    <div id="main-content">
        <div id="tooltip" class="tooltip">
            <div class="tooltip-header">
                <span id="tooltip-title" class="tooltip-title"></span>
                <span id="tooltip-filename" class="tooltip-filename"></span>
            </div>
            <div class="tooltip-abstract" id="tooltip-abstract"></div>
            <div class="tooltip-keywords" id="tooltip-keywords"></div>
            <a id="tooltip-link" class="tooltip-link" href="#" target="_blank">查看 PDF</a>
        </div>
        
        <div id="graph-container">
            <svg id="knowledge-graph"></svg>
        </div>
    </div>

<script type="module" src="src/web/js/main.js"></script> 
<script>
    // --- 调试开始：页面加载 ---
    console.log("页面加载：主脚本开始执行，保留现有背景，并专注于知识图谱功能实现。");

    // --- 全局 Canvas 变量和上下文 ---
    let particleCanvas;
    let ctx;
    let galaxyCenter = { x: 0, y: 0 }; // 初始为0，会在resizeCanvas中更新

    // --- 配置参数 (现有背景配置，不修改，仅作展示，D3部分会调整) ---
    const CONFIG = {
        // 背景粒子 (保持现有配置，不修改)
        numBackgroundParticles: 1000,
        minBackgroundParticleRadius: 0.5,
        maxBackgroundParticleRadius: 2.5,
        backgroundParticleFadeSpeed: 0.005,
        backgroundSpiralStrength: 0.0001,
        backgroundMovementSpeed: 0.2,
        backgroundInitialAlpha: 0.8,

        // 中心星体 (保持现有配置，不修改)
        starBodyBaseRadius: 30,
        starBodyAlphaSpeed: 0.003,
        starBodyMinAlpha: 0.2,
        starBodyMaxAlpha: 0.8,
        starBodyPulseSpeed: 0.001,

        // 星体散射粒子 (保持现有配置，不修改)
        numStarBodyParticles: 200,
        starBodyParticleSpeed: { min: 0.5, max: 2.0 },
        starBodyParticleRadius: { min: 0.8, max: 2.0 },
        starBodyParticleLifetime: { min: 1500, max: 3000 },

        // 行星/轨道粒子云 (保持现有配置，不修改)
        numOrbitingParticles: 120,
        orbitParticleRadius: { min: 1.5, max: 4 },
        orbitParticleSpeed: 0.01,
        orbitBaseDistance: 120,
        orbitDistanceVariance: 80,
        orbitShapeComplexity: 5,
        orbitShapeSpeed: 0.0005,
        orbitAlpha: 0.5,

        // 整体渲染 (保持现有配置，不修改)
        globalAlphaMultiplier: 1.0,
    };

    let starBodyAlpha = CONFIG.starBodyMinAlpha; // 星体当前透明度
    let starBodyPulse = 0; // 用于星体大小呼吸动画
    let orbitShapeOffset = 0; // 用于轨道形状动态变化

    // --- 粒子数组 ---
    const allParticles = []; // 包含背景粒子、星体散射粒子和轨道粒子云

    // --- 辅助函数：获取高级宇宙色 (保持现有背景颜色逻辑) ---
    function getUniverseColor(progress, baseHue = 0) {
        const hue = (baseHue + progress * 150 + Math.random() * 60 - 30) % 360;
        const saturation = 70 + Math.random() * 30;
        const lightness = 40 + Math.random() * 30;
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    // --- Canvas 尺寸调整函数 ---
    function resizeCanvas() {
        if (particleCanvas) {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            galaxyCenter.x = particleCanvas.width / 2;
            galaxyCenter.y = particleCanvas.height / 2;
            console.log(`Canvas resized: ${particleCanvas.width}x${particleCanvas.height}. Galaxy Center: (${galaxyCenter.x}, ${galaxyCenter.y})`);
            
            // 窗口大小改变时，重新初始化背景粒子以充满新尺寸
            allParticles.filter(p => p.type === 'background').forEach(p => p.markedForRemoval = true);
            // 确保背景粒子数量足够填充新尺寸
            while (allParticles.filter(p => p.type === 'background').length < CONFIG.numBackgroundParticles) {
                spawnBackgroundParticle(true); // 强制在整个新页面范围内生成
            }
        } else {
            console.warn("resizeCanvas: particleCanvas is not yet defined.");
        }
    }

    // --- 粒子类定义 ---
    class Particle {
        constructor(x, y, radius, color, velocity, type = 'background', initialAlpha = 1) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.velocity = velocity;
            this.alpha = initialAlpha; // 可设置初始透明度
            this.fadeSpeed = Math.random() * 0.005 + 0.002; // 调整淡出速度
            this.type = type;
            this.creationTime = Date.now();
            this.lifetime = Math.random() * CONFIG.starBodyParticleLifetime.max + CONFIG.starBodyParticleLifetime.min;
            this.markedForRemoval = false;
            // 额外属性用于拓扑形状粒子
            if (this.type === 'orbit') {
                this.initialAngle = Math.random() * Math.PI * 2; // 粒子在轨道上的初始角度
                this.distanceFactor = Math.random(); // 决定粒子离中心远近
                this.orbitHueOffset = Math.random(); // 用于颜色渐变
            }
        }

        draw() {
            if (!ctx) return;
            ctx.save();
            ctx.globalAlpha = this.alpha * CONFIG.globalAlphaMultiplier; // 整体透明度控制
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }

        update() {
            if (this.type === 'background') {
                const dx = this.x - galaxyCenter.x;
                const dy = this.y - galaxyCenter.y;
                let angle = Math.atan2(dy, dx);
                let distanceFromCenter = Math.sqrt(dx * dx + dy * dy);

                const maxBackgroundRadius = Math.max(particleCanvas.width, particleCanvas.height) * 0.6;
                if (distanceFromCenter > maxBackgroundRadius * 1.5) {
                    this.markedForRemoval = true;
                    return;
                }

                const rotationFactor = 0.005 * (1 - Math.pow(distanceFromCenter / maxBackgroundRadius, 1.5)); // 螺旋旋转
                angle += (this.velocity.rotationSpeed) * rotationFactor;

                distanceFromCenter += Math.sin(angle * 5) * CONFIG.backgroundSpiralStrength * distanceFromCenter;

                this.x = galaxyCenter.x + distanceFromCenter * Math.cos(angle);
                this.y = galaxyCenter.y + distanceFromCenter * Math.sin(angle);

                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= this.fadeSpeed;

                if (this.alpha <= 0) {
                    this.markedForRemoval = true;
                }
            } else if (this.type === 'starBody') {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha = 1 - (Date.now() - this.creationTime) / this.lifetime;
                if (this.alpha <= 0) {
                    this.markedForRemoval = true;
                }
            } else if (this.type === 'orbit') {
                this.initialAngle += CONFIG.orbitParticleSpeed;

                const shapeModifier = Math.sin(this.initialAngle * CONFIG.orbitShapeComplexity + orbitShapeOffset) * 0.5 + 0.5;
                const distance = CONFIG.orbitBaseDistance + CONFIG.orbitDistanceVariance * this.distanceFactor * shapeModifier;

                this.x = galaxyCenter.x + distance * Math.cos(this.initialAngle);
                this.y = galaxyCenter.y + distance * Math.sin(this.initialAngle);

                this.color = getUniverseColor(this.orbitHueOffset + shapeModifier * 0.1, 240); // 蓝色调
                this.alpha = CONFIG.orbitAlpha + Math.abs(Math.sin(this.initialAngle * 2)) * 0.3; // 动态透明度
            }
        }
    }

    // --- 核心动画函数 ---
    function animate() {
        requestAnimationFrame(animate);

        if (!ctx || !particleCanvas) {
            console.error("Canvas context or element not ready for animation.");
            return;
        }

        ctx.fillStyle = '#0a0a1a'; // 宇宙背景色 (保持现有)
        ctx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);

        // 更新星体闪烁和呼吸
        starBodyAlpha = CONFIG.starBodyMinAlpha + (CONFIG.starBodyMaxAlpha - CONFIG.starBodyMinAlpha) * ((Math.sin(Date.now() * CONFIG.starBodyAlphaSpeed) + 1) / 2);
        starBodyPulse = (Math.sin(Date.now() * CONFIG.starBodyPulseSpeed) + 1) / 2;

        // 更新轨道形状偏移量
        orbitShapeOffset += CONFIG.orbitShapeSpeed;

        // 1. 更新并绘制背景粒子 (层级最低)
        for (let i = allParticles.length - 1; i >= 0; i--) {
            const particle = allParticles[i];
            if (particle.type === 'background') {
                particle.update();
                particle.draw();
                if (particle.markedForRemoval) {
                    allParticles.splice(i, 1);
                    spawnBackgroundParticle();
                }
            }
        }

        // 2. 绘制中心星体及散射粒子 (中层)
        drawStarBody();
        // 更新并绘制星体散射粒子
        for (let i = allParticles.length - 1; i >= 0; i--) {
            const particle = allParticles[i];
            if (particle.type === 'starBody') {
                particle.update();
                particle.draw();
                if (particle.markedForRemoval) {
                    allParticles.splice(i, 1);
                }
            }
        }
        // 确保星体散射粒子数量
        const currentStarBodyParticlesCount = allParticles.filter(p => p.type === 'starBody').length;
        if (currentStarBodyParticlesCount < CONFIG.numStarBodyParticles) {
            spawnStarBodyParticle();
        }

        // 3. 绘制轨道粒子云 (中上层)
        for (let i = allParticles.length - 1; i >= 0; i--) {
            const particle = allParticles[i];
            if (particle.type === 'orbit') {
                particle.update();
                particle.draw();
            }
        }
    }

    // --- 生成背景粒子 ---
    function spawnBackgroundParticle(forceFullPage = false) {
        const radius = Math.random() * (CONFIG.maxBackgroundParticleRadius - CONFIG.minBackgroundParticleRadius) + CONFIG.minBackgroundParticleRadius;
        const angle = Math.random() * Math.PI * 2;
        let distance;
        
        if (forceFullPage || Math.random() < 0.2) { // 20%的粒子在屏幕边缘生成，其余在中心区域
             distance = Math.random() * Math.max(particleCanvas.width, particleCanvas.height) * 0.7;
        } else {
             distance = Math.random() * Math.min(particleCanvas.width, particleCanvas.height) * 0.3; // 更靠近中心
        }

        const x = galaxyCenter.x + distance * Math.cos(angle);
        const y = galaxyCenter.y + distance * Math.sin(angle);

        let color;
        const colorProgress = Math.random();
        if (colorProgress < 0.4) {
            color = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})`;
        } else if (colorProgress < 0.7) {
            color = `rgba(150, 200, 255, ${Math.random() * 0.5 + 0.3})`;
        } else {
            color = `rgba(200, 150, 255, ${Math.random() * 0.5 + 0.3})`;
        }

        const velocity = {
            x: (Math.random() - 0.5) * CONFIG.backgroundMovementSpeed,
            y: (Math.random() - 0.5) * CONFIG.backgroundMovementSpeed,
            rotationSpeed: (Math.random() * 0.005 + 0.001) * (Math.random() < 0.5 ? 1 : -1)
        };
        allParticles.push(new Particle(x, y, radius, color, velocity, 'background', CONFIG.backgroundInitialAlpha));
    }

    // --- 生成星体散射粒子 ---
    function spawnStarBodyParticle() {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * (CONFIG.starBodyParticleSpeed.max - CONFIG.starBodyParticleSpeed.min) + CONFIG.starBodyParticleSpeed.min;
        const starBodyCurrentRadius = CONFIG.starBodyBaseRadius + starBodyPulse * 10;
        const x = galaxyCenter.x + Math.cos(angle) * (starBodyCurrentRadius * 0.5);
        const y = galaxyCenter.y + Math.sin(angle) * (starBodyCurrentRadius * 0.5);
        const velocity = {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed
        };
        const radius = Math.random() * (CONFIG.starBodyParticleRadius.max - CONFIG.starBodyParticleRadius.min) + CONFIG.starBodyParticleRadius.min;
        const color = getUniverseColor(Math.random(), 0); // 彩虹色
        allParticles.push(new Particle(x, y, radius, color, velocity, 'starBody', starBodyAlpha));
    }

    // --- 初始化轨道粒子云 ---
    function initOrbitingParticles() {
        for (let i = 0; i < CONFIG.numOrbitingParticles; i++) {
            const radius = Math.random() * (CONFIG.orbitParticleRadius.max - CONFIG.orbitParticleRadius.min) + CONFIG.orbitParticleRadius.min;
            const initialAngle = Math.random() * Math.PI * 2;
            const distanceFactor = Math.random();
            const color = getUniverseColor(Math.random(), 240);
            allParticles.push(new Particle(0, 0, radius, color, {x:0, y:0}, 'orbit', CONFIG.orbitAlpha));
        }
        console.log("轨道粒子云初始化完成。");
    }

    // --- 绘制中心星体 ---
    function drawStarBody() {
        const currentStarRadius = CONFIG.starBodyBaseRadius + starBodyPulse * 10;

        // 绘制中心彩虹色光晕
        const gradient = ctx.createRadialGradient(
            galaxyCenter.x, galaxyCenter.y, 0,
            galaxyCenter.x, galaxyCenter.y, currentStarRadius * 3
        );
        for (let i = 0; i <= 10; i++) {
            const progress = i / 10;
            const hue = (progress * 180 + starBodyPulse * 60) % 360;
            const saturation = 80 + progress * 20;
            const lightness = 50 + progress * 10;
            gradient.addColorStop(progress, `hsla(${hue}, ${saturation}%, ${lightness}%, ${starBodyAlpha * (1 - progress * 0.7)})`);
        }
        ctx.beginPath();
        ctx.arc(galaxyCenter.x, galaxyCenter.y, currentStarRadius * 3, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // 绘制星体核心
        ctx.beginPath();
        ctx.arc(galaxyCenter.x, galaxyCenter.y, currentStarRadius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${starBodyAlpha})`;
        ctx.shadowColor = `rgba(255, 255, 255, ${starBodyAlpha * 0.7})`;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // --- 初始化背景动画函数 (在 DOMContentLoaded 之后执行) ---
    function initGalaxyAnimation() {
        particleCanvas = document.getElementById('particle-canvas');
        if (!particleCanvas) {
            console.error("初始化错误：未找到 ID 为 'particle-canvas' 的元素！请确保 HTML 中存在此元素。");
            alert("加载失败：粒子背景 Canvas 元素不存在。请检查 HTML 结构。");
            return;
        }

        ctx = particleCanvas.getContext('2d');
        if (!ctx) {
            console.error("初始化错误：无法获取 Canvas 2D 上下文！");
            alert("加载失败：无法获取 Canvas 绘图上下文。");
            return;
        }
        console.log("Canvas 元素找到并获取到 2D 上下文。");

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        for (let i = 0; i < CONFIG.numBackgroundParticles; i++) {
            spawnBackgroundParticle();
        }

        initOrbitingParticles();
        
        console.log("所有粒子和动态元素初始化完成。");

        animate();
        console.log("宇宙星系背景动画已启动！");
    }

    // --- 在 DOMContentLoaded 事件触发时初始化背景动画 ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded 事件触发。开始初始化背景动画。知识图谱由 main.js 处理。");
        initGalaxyAnimation(); // 确保背景首先出现并运行
    });
</script>
</body>
</html>
