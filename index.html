<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超高级知识图谱</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* 全局样式 */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e; /* 深蓝色背景，为星空做准备 */
            color: #e0e0e0; /* 浅色字体 */
            display: flex; /* 使用 flex 布局 */
            min-height: 100vh; /* 确保占据整个视口高度 */
            overflow: hidden; /* 防止滚动条 */
        }

        /* 星空粒子 Canvas 样式 */
        #particle-canvas {
            position: fixed; /* 固定定位，使其覆盖整个屏幕 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* 确保它在所有内容之下 */
            background-color: #1a1a2e; /* 确保有深色背景，防止透明显示默认的白色 */
        }

        /* 侧边栏样式 */
        #sidebar {
            width: 250px; /* 固定宽度 */
            background-color: rgba(25, 25, 45, 0.9); /* 深色半透明背景 */
            padding: 20px 0;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100; /* 确保在粒子背景之上 */
        }

        #sidebar h2 {
            color: #8be9fd; /* 标题颜色 */
            text-align: center;
            margin-top: 0;
            margin-bottom: 30px;
            padding: 0 15px;
            font-size: 1.6em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 15px;
        }

        #pdf-list {
            list-style: none;
            padding: 0 15px;
            margin: 0;
            flex-grow: 1; /* 占据剩余空间 */
            overflow-y: auto; /* 允许滚动 */
        }

        #pdf-list li {
            margin-bottom: 8px;
        }

        #pdf-list a {
            color: #b3cde0; /* 链接颜色 */
            text-decoration: none;
            padding: 8px 10px;
            display: block;
            border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        #pdf-list a:hover {
            background-color: rgba(139, 233, 253, 0.1); /* 悬停背景 */
            color: #8be9fd;
        }

        /* 主内容区域 */
        #main-content {
            flex-grow: 1; /* 占据剩余宽度 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* 垂直居中图谱 */
            position: relative;
        }

        #graph-container {
            width: 95%; /* 适应屏幕宽度 */
            height: 90vh; /* 适应屏幕高度 */
            background-color: transparent; /* 背景透明，透出粒子 */
            border-radius: 8px;
            position: relative;
        }

        /* D3 元素样式 */
        .node circle {
            fill: #8be9fd; /* 节点颜色调整为亮蓝色 */
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
            transition: all 0.2s ease; /* 添加过渡效果 */
        }
        .node circle:hover {
            fill: #ff79c6; /* 悬停颜色 */
            stroke-width: 3px;
        }
        .node text {
            font-size: 11px;
            fill: #f8f8f2; /* 文本颜色调整为浅色 */
            text-anchor: middle;
            pointer-events: none; /* 允许点击穿透到下面的 circle */
            user-select: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* 文本阴影增强可读性 */
        }
        .link {
            stroke: #bd93f9; /* 链接颜色调整为紫色 */
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }

        /* Tooltip 样式 */
        .tooltip {
            position: absolute;
            background-color: rgba(30, 30, 50, 0.95); /* 深色半透明背景 */
            border: 1px solid rgba(139, 233, 253, 0.5); /* 边框与节点颜色协调 */
            border-radius: 6px;
            padding: 15px;
            pointer-events: none; /* 允许鼠标事件穿透，不阻挡图谱交互 */
            opacity: 0; /* 默认隐藏 */
            transition: opacity 0.2s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            max-width: 300px; /* 最大宽度 */
            z-index: 200; /* 确保在最上层 */
            color: #e0e0e0;
            font-size: 14px;
            line-height: 1.5;
        }

        .tooltip.active {
            opacity: 1; /* 激活时显示 */
        }

        .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .tooltip-title {
            font-weight: bold;
            color: #8be9fd; /* 标题颜色 */
            font-size: 1.1em;
            flex-grow: 1;
            margin-right: 10px;
        }

        .tooltip-filename {
            font-size: 0.8em;
            color: #a0a0a0;
            white-space: nowrap; /* 不换行 */
        }

        .tooltip-abstract {
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #b3cde0;
            max-height: 100px; /* 限制摘要高度 */
            overflow-y: auto; /* 允许滚动 */
        }

        .tooltip-keywords {
            font-style: italic;
            font-size: 0.85em;
            color: #bd93f9; /* 关键词颜色 */
            margin-bottom: 10px;
        }

        .tooltip-link {
            display: inline-block;
            background-color: #ff79c6; /* 链接按钮颜色 */
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        .tooltip-link:hover {
            background-color: #ff55aa;
        }
    </style>
</head>
<body>
   <canvas id="particle-canvas"></canvas>
    <div id="sidebar">
        <h2 >Mind-of-Ai'lab by BH_Y</h2>
        <h3 src="D:\my-knowledge-graph\data\pdfs\2405.20441v4.pdf">welcom</h3>
        <ul id="pdf-list">
            </ul>
    </div>
    <div id="main-content">
        <div id="tooltip" class="tooltip">
            <div class="tooltip-header">
                <span id="tooltip-title" class="tooltip-title"></span>
                <span id="tooltip-filename" class="tooltip-filename"></span>
            </div>
            <div class="tooltip-abstract" id="tooltip-abstract"></div>
            <div class="tooltip-keywords" id="tooltip-keywords"></div>
            <a id="tooltip-link" class="tooltip-link" href="#" target="_blank">查看 PDF</a>
        </div>
        
        <div id="graph-container">
            <svg id="knowledge-graph"></svg>
        </div>
    </div>

<script>
    // --- 调试开始：页面加载 ---
    console.log("页面加载：主脚本开始执行，保留现有背景，并专注于知识图谱功能实现。");

    // --- 全局 Canvas 变量和上下文 ---
    let particleCanvas;
    let ctx;
    let galaxyCenter = { x: 0, y: 0 }; // 初始为0，会在resizeCanvas中更新

    // --- 配置参数 (现有背景配置，不修改，仅作展示，D3部分会调整) ---
    const CONFIG = {
        // 背景粒子 (保持现有配置，不修改)
        numBackgroundParticles: 1000,
        minBackgroundParticleRadius: 0.5,
        maxBackgroundParticleRadius: 2.5,
        backgroundParticleFadeSpeed: 0.005,
        backgroundSpiralStrength: 0.0001,
        backgroundMovementSpeed: 0.2,
        backgroundInitialAlpha: 0.8,

        // 中心星体 (保持现有配置，不修改)
        starBodyBaseRadius: 30,
        starBodyAlphaSpeed: 0.003,
        starBodyMinAlpha: 0.2,
        starBodyMaxAlpha: 0.8,
        starBodyPulseSpeed: 0.001,

        // 星体散射粒子 (保持现有配置，不修改)
        numStarBodyParticles: 200,
        starBodyParticleSpeed: { min: 0.5, max: 2.0 },
        starBodyParticleRadius: { min: 0.8, max: 2.0 },
        starBodyParticleLifetime: { min: 1500, max: 3000 },

        // 行星/轨道粒子云 (保持现有配置，不修改)
        numOrbitingParticles: 120,
        orbitParticleRadius: { min: 1.5, max: 4 },
        orbitParticleSpeed: 0.01,
        orbitBaseDistance: 120,
        orbitDistanceVariance: 80,
        orbitShapeComplexity: 5,
        orbitShapeSpeed: 0.0005,
        orbitAlpha: 0.5,

        // 整体渲染 (保持现有配置，不修改)
        globalAlphaMultiplier: 1.0,

        // D3 图谱相关配置 (重点调整，确保在背景上清晰可见且交互流畅)
        d3: {
            nodeBaseRadius: 8, // 节点基础半径，相对均匀，略小
            nodeHighlightRadiusIncrease: 8, // 鼠标悬停时节点半径增加量
            linkDistance: 100, // 链接默认长度，适中，方便形成聚类
            chargeStrength: -500, // 节点斥力，适度，让节点有聚类感同时避免完全重叠
            collisionRadius: 20, // 节点碰撞半径，略大于最大节点尺寸以防止重叠
            alphaDecay: 0.02, // 模拟冷却速度，使布局更快稳定
            linkStrength: 0.7, // 链接强度，适中
            nodeStrokeWidth: 2, // 节点边框粗细
            nodeHighlightStrokeWidth: 4, // 节点高亮边框粗细
            linkStrokeWidth: 1, // 连线默认粗细
            linkHighlightStrokeWidth: 3, // 连线高亮粗细
            linkOpacity: 0.3, // 连线默认透明度，使其背景化
            linkHighlightOpacity: 0.8 // 连线高亮透明度
        }
    };

    let starBodyAlpha = CONFIG.starBodyMinAlpha; // 星体当前透明度
    let starBodyPulse = 0; // 用于星体大小呼吸动画
    let orbitShapeOffset = 0; // 用于轨道形状动态变化

    // --- 粒子数组 ---
    const allParticles = []; // 包含背景粒子、星体散射粒子和轨道粒子云

    // --- 辅助函数：获取高级宇宙色 (保持现有背景颜色逻辑) ---
    function getUniverseColor(progress, baseHue = 0) {
        const hue = (baseHue + progress * 150 + Math.random() * 60 - 30) % 360;
        const saturation = 70 + Math.random() * 30;
        const lightness = 40 + Math.random() * 30;
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    // --- Canvas 尺寸调整函数 ---
    function resizeCanvas() {
        if (particleCanvas) {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            galaxyCenter.x = particleCanvas.width / 2;
            galaxyCenter.y = particleCanvas.height / 2;
            console.log(`Canvas resized: ${particleCanvas.width}x${particleCanvas.height}. Galaxy Center: (${galaxyCenter.x}, ${galaxyCenter.y})`);
            
            // 窗口大小改变时，重新初始化背景粒子以充满新尺寸
            allParticles.filter(p => p.type === 'background').forEach(p => p.markedForRemoval = true);
            // 确保背景粒子数量足够填充新尺寸
            while (allParticles.filter(p => p.type === 'background').length < CONFIG.numBackgroundParticles) {
                spawnBackgroundParticle(true); // 强制在整个新页面范围内生成
            }
        } else {
            console.warn("resizeCanvas: particleCanvas is not yet defined.");
        }
    }

    // --- 粒子类定义 ---
    class Particle {
        constructor(x, y, radius, color, velocity, type = 'background', initialAlpha = 1) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.velocity = velocity;
            this.alpha = initialAlpha; // 可设置初始透明度
            this.fadeSpeed = Math.random() * 0.005 + 0.002; // 调整淡出速度
            this.type = type;
            this.creationTime = Date.now();
            this.lifetime = Math.random() * CONFIG.starBodyParticleLifetime.max + CONFIG.starBodyParticleLifetime.min;
            this.markedForRemoval = false;
            // 额外属性用于拓扑形状粒子
            if (this.type === 'orbit') {
                this.initialAngle = Math.random() * Math.PI * 2; // 粒子在轨道上的初始角度
                this.distanceFactor = Math.random(); // 决定粒子离中心远近
                this.orbitHueOffset = Math.random(); // 用于颜色渐变
            }
        }

        draw() {
            if (!ctx) return;
            ctx.save();
            ctx.globalAlpha = this.alpha * CONFIG.globalAlphaMultiplier; // 整体透明度控制
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }

        update() {
            if (this.type === 'background') {
                const dx = this.x - galaxyCenter.x;
                const dy = this.y - galaxyCenter.y;
                let angle = Math.atan2(dy, dx);
                let distanceFromCenter = Math.sqrt(dx * dx + dy * dy);

                const maxBackgroundRadius = Math.max(particleCanvas.width, particleCanvas.height) * 0.6;
                if (distanceFromCenter > maxBackgroundRadius * 1.5) {
                    this.markedForRemoval = true;
                    return;
                }

                const rotationFactor = 0.005 * (1 - Math.pow(distanceFromCenter / maxBackgroundRadius, 1.5)); // 螺旋旋转
                angle += (this.velocity.rotationSpeed) * rotationFactor;

                distanceFromCenter += Math.sin(angle * 5) * CONFIG.backgroundSpiralStrength * distanceFromCenter;

                this.x = galaxyCenter.x + distanceFromCenter * Math.cos(angle);
                this.y = galaxyCenter.y + distanceFromCenter * Math.sin(angle);

                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= this.fadeSpeed;

                if (this.alpha <= 0) {
                    this.markedForRemoval = true;
                }
            } else if (this.type === 'starBody') {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha = 1 - (Date.now() - this.creationTime) / this.lifetime;
                if (this.alpha <= 0) {
                    this.markedForRemoval = true;
                }
            } else if (this.type === 'orbit') {
                this.initialAngle += CONFIG.orbitParticleSpeed;

                const shapeModifier = Math.sin(this.initialAngle * CONFIG.orbitShapeComplexity + orbitShapeOffset) * 0.5 + 0.5;
                const distance = CONFIG.orbitBaseDistance + CONFIG.orbitDistanceVariance * this.distanceFactor * shapeModifier;

                this.x = galaxyCenter.x + distance * Math.cos(this.initialAngle);
                this.y = galaxyCenter.y + distance * Math.sin(this.initialAngle);

                this.color = getUniverseColor(this.orbitHueOffset + shapeModifier * 0.1, 240); // 蓝色调
                this.alpha = CONFIG.orbitAlpha + Math.abs(Math.sin(this.initialAngle * 2)) * 0.3; // 动态透明度
            }
        }
    }

    // --- 核心动画函数 ---
    function animate() {
        requestAnimationFrame(animate);

        if (!ctx || !particleCanvas) {
            console.error("Canvas context or element not ready for animation.");
            return;
        }

        ctx.fillStyle = '#0a0a1a'; // 宇宙背景色 (保持现有)
        ctx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);

        // 更新星体闪烁和呼吸
        starBodyAlpha = CONFIG.starBodyMinAlpha + (CONFIG.starBodyMaxAlpha - CONFIG.starBodyMinAlpha) * ((Math.sin(Date.now() * CONFIG.starBodyAlphaSpeed) + 1) / 2);
        starBodyPulse = (Math.sin(Date.now() * CONFIG.starBodyPulseSpeed) + 1) / 2;

        // 更新轨道形状偏移量
        orbitShapeOffset += CONFIG.orbitShapeSpeed;

        // 1. 更新并绘制背景粒子 (层级最低)
        for (let i = allParticles.length - 1; i >= 0; i--) {
            const particle = allParticles[i];
            if (particle.type === 'background') {
                particle.update();
                particle.draw();
                if (particle.markedForRemoval) {
                    allParticles.splice(i, 1);
                    spawnBackgroundParticle();
                }
            }
        }

        // 2. 绘制中心星体及散射粒子 (中层)
        drawStarBody();
        // 更新并绘制星体散射粒子
        for (let i = allParticles.length - 1; i >= 0; i--) {
            const particle = allParticles[i];
            if (particle.type === 'starBody') {
                particle.update();
                particle.draw();
                if (particle.markedForRemoval) {
                    allParticles.splice(i, 1);
                }
            }
        }
        // 确保星体散射粒子数量
        const currentStarBodyParticlesCount = allParticles.filter(p => p.type === 'starBody').length;
        if (currentStarBodyParticlesCount < CONFIG.numStarBodyParticles) {
            spawnStarBodyParticle();
        }

        // 3. 绘制轨道粒子云 (中上层)
        for (let i = allParticles.length - 1; i >= 0; i--) {
            const particle = allParticles[i];
            if (particle.type === 'orbit') {
                particle.update();
                particle.draw();
            }
        }
    }

    // --- 生成背景粒子 ---
    function spawnBackgroundParticle(forceFullPage = false) {
        const radius = Math.random() * (CONFIG.maxBackgroundParticleRadius - CONFIG.minBackgroundParticleRadius) + CONFIG.minBackgroundParticleRadius;
        const angle = Math.random() * Math.PI * 2;
        let distance;
        
        if (forceFullPage || Math.random() < 0.2) { // 20%的粒子在屏幕边缘生成，其余在中心区域
             distance = Math.random() * Math.max(particleCanvas.width, particleCanvas.height) * 0.7;
        } else {
             distance = Math.random() * Math.min(particleCanvas.width, particleCanvas.height) * 0.3; // 更靠近中心
        }

        const x = galaxyCenter.x + distance * Math.cos(angle);
        const y = galaxyCenter.y + distance * Math.sin(angle);

        let color;
        const colorProgress = Math.random();
        if (colorProgress < 0.4) {
            color = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})`;
        } else if (colorProgress < 0.7) {
            color = `rgba(150, 200, 255, ${Math.random() * 0.5 + 0.3})`;
        } else {
            color = `rgba(200, 150, 255, ${Math.random() * 0.5 + 0.3})`;
        }

        const velocity = {
            x: (Math.random() - 0.5) * CONFIG.backgroundMovementSpeed,
            y: (Math.random() - 0.5) * CONFIG.backgroundMovementSpeed,
            rotationSpeed: (Math.random() * 0.005 + 0.001) * (Math.random() < 0.5 ? 1 : -1)
        };
        allParticles.push(new Particle(x, y, radius, color, velocity, 'background', CONFIG.backgroundInitialAlpha));
    }

    // --- 生成星体散射粒子 ---
    function spawnStarBodyParticle() {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * (CONFIG.starBodyParticleSpeed.max - CONFIG.starBodyParticleSpeed.min) + CONFIG.starBodyParticleSpeed.min;
        const starBodyCurrentRadius = CONFIG.starBodyBaseRadius + starBodyPulse * 10;
        const x = galaxyCenter.x + Math.cos(angle) * (starBodyCurrentRadius * 0.5);
        const y = galaxyCenter.y + Math.sin(angle) * (starBodyCurrentRadius * 0.5);
        const velocity = {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed
        };
        const radius = Math.random() * (CONFIG.starBodyParticleRadius.max - CONFIG.starBodyParticleRadius.min) + CONFIG.starBodyParticleRadius.min;
        const color = getUniverseColor(Math.random(), 0); // 彩虹色
        allParticles.push(new Particle(x, y, radius, color, velocity, 'starBody', starBodyAlpha));
    }

    // --- 初始化轨道粒子云 ---
    function initOrbitingParticles() {
        for (let i = 0; i < CONFIG.numOrbitingParticles; i++) {
            const radius = Math.random() * (CONFIG.orbitParticleRadius.max - CONFIG.orbitParticleRadius.min) + CONFIG.orbitParticleRadius.min;
            const initialAngle = Math.random() * Math.PI * 2;
            const distanceFactor = Math.random();
            const color = getUniverseColor(Math.random(), 240);
            allParticles.push(new Particle(0, 0, radius, color, {x:0, y:0}, 'orbit', CONFIG.orbitAlpha));
        }
        console.log("轨道粒子云初始化完成。");
    }

    // --- 绘制中心星体 ---
    function drawStarBody() {
        const currentStarRadius = CONFIG.starBodyBaseRadius + starBodyPulse * 10;

        // 绘制中心彩虹色光晕
        const gradient = ctx.createRadialGradient(
            galaxyCenter.x, galaxyCenter.y, 0,
            galaxyCenter.x, galaxyCenter.y, currentStarRadius * 3
        );
        for (let i = 0; i <= 10; i++) {
            const progress = i / 10;
            const hue = (progress * 180 + starBodyPulse * 60) % 360;
            const saturation = 80 + progress * 20;
            const lightness = 50 + progress * 10;
            gradient.addColorStop(progress, `hsla(${hue}, ${saturation}%, ${lightness}%, ${starBodyAlpha * (1 - progress * 0.7)})`);
        }
        ctx.beginPath();
        ctx.arc(galaxyCenter.x, galaxyCenter.y, currentStarRadius * 3, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // 绘制星体核心
        ctx.beginPath();
        ctx.arc(galaxyCenter.x, galaxyCenter.y, currentStarRadius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${starBodyAlpha})`;
        ctx.shadowColor = `rgba(255, 255, 255, ${starBodyAlpha * 0.7})`;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // --- 初始化背景动画函数 (在 DOMContentLoaded 之后执行) ---
    function initGalaxyAnimation() {
        particleCanvas = document.getElementById('particle-canvas');
        if (!particleCanvas) {
            console.error("初始化错误：未找到 ID 为 'particle-canvas' 的元素！请确保 HTML 中存在此元素。");
            alert("加载失败：粒子背景 Canvas 元素不存在。请检查 HTML 结构。");
            return;
        }

        ctx = particleCanvas.getContext('2d');
        if (!ctx) {
            console.error("初始化错误：无法获取 Canvas 2D 上下文！");
            alert("加载失败：无法获取 Canvas 绘图上下文。");
            return;
        }
        console.log("Canvas 元素找到并获取到 2D 上下文。");

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        for (let i = 0; i < CONFIG.numBackgroundParticles; i++) {
            spawnBackgroundParticle();
        }

        initOrbitingParticles();
        
        console.log("所有粒子和动态元素初始化完成。");

        animate();
        console.log("宇宙星系背景动画已启动！");
    }

    // --- D3 图谱和交互逻辑在 DOMContentLoaded 之后执行 ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded 事件触发。开始初始化所有动态元素和D3图谱。");

        initGalaxyAnimation(); // 确保背景首先出现并运行

        const svgElement = document.getElementById('knowledge-graph');
        const container = document.getElementById('graph-container');
        const pdfListElement = document.getElementById('pdf-list');

        const tooltipContainer = document.getElementById('tooltip');
        const tooltipTitle = document.getElementById('tooltip-title');
        const tooltipFilename = document.getElementById('tooltip-filename');
        const tooltipAbstract = document.getElementById('tooltip-abstract');
        const tooltipKeywords = document.getElementById('tooltip-keywords');
        const tooltipLink = document.getElementById('tooltip-link');

        const tooltipElements = {
            container: tooltipContainer,
            title: tooltipTitle,
            filename: tooltipFilename,
            abstract: tooltipAbstract,
            keywords: tooltipKeywords,
            link: tooltipLink
        };

        if (!svgElement) {
            console.error("错误：未找到 ID 为 'knowledge-graph' 的 SVG 元素！图谱无法初始化。");
            alert("加载失败：SVG 元素不存在。请检查 HTML 结构。");
            return;
        }
        if (!container) {
            console.error("错误：未找到 ID 为 'graph-container' 的容器元素！图谱布局可能不正确。");
            alert("加载失败：图谱容器不存在。请检查 HTML 结构。");
            return;
        }
        if (!pdfListElement) {
            console.warn("警告：未找到 ID 为 'pdf-list' 的元素！PDF 列表无法填充。");
        }
        if (!tooltipContainer) {
            console.warn("警告：未找到 ID 为 'tooltip' 的元素！Tooltip 无法工作。");
        }

        const width = container.offsetWidth;
        const height = container.offsetHeight;
        svgElement.setAttribute('width', width);
        svgElement.setAttribute('height', height);
        console.log(`SVG 宽度: ${width}, 高度: ${height}`);

        const svg = d3.select(svgElement);
        svg.selectAll("*").remove(); // 清除旧的图谱元素，防止重复加载

        const g = svg.append("g"); // 用于承载所有图谱元素的组，便于缩放和平移

        // 实现缩放和平移
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10]) // 允许的缩放范围
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        svg.call(zoom);

        // 为节点定义颜色方案，可以根据需要扩展或更改
        // 使用D3的Categorical scheme，确保颜色区分度
        const colors = d3.scaleOrdinal(d3.schemeCategory10); // D3自带的10种区分度高的颜色

        console.log("尝试加载 ../data/processed_data.json...");
        fetch('../data/processed_data.json')
            .then(response => {
                console.log("文件加载响应状态:", response.status);
                if (!response.ok) {
                    throw new Error(`HTTP 错误! 状态: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("processed_data.json 数据成功加载并解析:", data);

                if (!data || !data.graph || !data.documents) {
                    console.error("数据结构不正确：缺少 'graph' 或 'documents'。", data);
                    alert("加载知识图谱数据失败：数据结构不正确。");
                    return;
                }
                if (!data.graph.nodes || data.graph.nodes.length === 0) {
                    console.warn("图谱数据中没有节点。");
                }
                if (!data.graph.links || data.graph.links.length === 0) {
                    console.warn("图谱数据中没有链接。");
                }

                const documentsMap = new Map(data.documents.map(doc => [doc.id, doc]));
                console.log("Documents Map created:", documentsMap);

                const graphData = data.graph;

                // 尝试根据文档的某个属性（例如第一个关键词）来给节点分组和着色
                // 如果processed_data.json中的文档没有明确的类别，可以随机分配或者基于某种启发式方法
                graphData.nodes.forEach(node => {
                    const doc = documentsMap.get(node.id);
                    if (doc && doc.keywords && doc.keywords.length > 0) {
                        // 使用第一个关键词作为分类依据
                        node.category = doc.keywords[0]; 
                    } else {
                        // 如果没有关键词，可以分配一个默认类别或者随机类别
                        node.category = "Uncategorized"; 
                    }
                });
                console.log("节点类别分配完成。");


                // 计算每个节点的度（连接数），用于调整节点大小
                const nodeDegrees = new Map();
                graphData.links.forEach(link => {
                    nodeDegrees.set(link.source, (nodeDegrees.get(link.source) || 0) + 1);
                    nodeDegrees.set(link.target, (nodeDegrees.get(link.target) || 0) + 1);
                });
                graphData.nodes.forEach(node => {
                    node.degree = nodeDegrees.get(node.id) || 0;
                });
                console.log("节点度数计算完成。");

                // --- D3 力导向图渲染 ---
                const simulation = d3.forceSimulation(graphData.nodes)
                    .force("link", d3.forceLink(graphData.links)
                        .id(d => d.id)
                        .distance(CONFIG.d3.linkDistance) // 链接间距
                        .strength(CONFIG.d3.linkStrength)) // 链接强度
                    .force("charge", d3.forceManyBody().strength(CONFIG.d3.chargeStrength)) // 节点斥力
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collide", d3.forceCollide().radius(d => CONFIG.d3.nodeBaseRadius + (d.degree / 2) + 2)) // 基于度数调整碰撞半径，确保不重叠
                    .alphaDecay(CONFIG.d3.alphaDecay); // 模拟冷却速度

                // 添加发光滤镜定义 (SVG <defs>)
                const defs = svg.append("defs");
                const filter = defs.append("filter")
                    .attr("id", "glow");
                filter.append("feGaussianBlur")
                    .attr("stdDeviation", "3.0") // 适度发光
                    .attr("result", "coloredBlur");
                const feMerge = filter.append("feMerge");
                feMerge.append("feMergeNode")
                    .attr("in", "coloredBlur");
                feMerge.append("feMergeNode")
                    .attr("in", "SourceGraphic");

                // 绘制链接 (细的、透明的灰色或黑色)
                const link = g.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graphData.links)
                    .enter().append("line")
                    .attr("class", "link")
                    .attr("stroke", "rgba(128, 128, 128, 0.3)") // 默认细、透明灰色
                    .attr("stroke-width", CONFIG.d3.linkStrokeWidth);

                // 绘制节点 (圆形，无文本标签)
                const node = g.append("g")
                    .attr("class", "nodes")
                    .selectAll(".node")
                    .data(graphData.nodes)
                    .enter().append("g")
                    .attr("class", "node")
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended));

                node.append("circle")
                    .attr("r", d => CONFIG.d3.nodeBaseRadius + (d.degree / 4)) // 节点半径根据度数微调，保持相对均匀
                    .attr("data-id", d => d.id) // 用于查找节点
                    .attr("fill", d => colors(d.category)) // 根据类别分配颜色
                    .attr("stroke", d => d3.color(colors(d.category)).darker(0.5)) // 边框颜色更深
                    .attr("stroke-width", CONFIG.d3.nodeStrokeWidth) // 边框粗细
                    .style("filter", "url(#glow)"); // 应用发光滤镜


                // --- 节点鼠标事件 (Tooltip 显示/隐藏 和 点击跳转) ---
                node.on("mouseover", (event, d) => {
                    const doc = documentsMap.get(d.id);
                    if (doc && tooltipElements.container) {
                        tooltipElements.title.textContent = doc.title || 'N/A';
                        tooltipElements.filename.textContent = doc.filename ? `文件: ${doc.filename}` : 'N/A';
                        tooltipElements.abstract.textContent = doc.abstract || '无摘要';
                        tooltipElements.keywords.textContent = `关键词: ${doc.keywords && doc.keywords.length > 0 ? doc.keywords.join(', ') : '无'}`;
                        tooltipElements.link.href = `../data/pdfs/${doc.filename}` || '#';
                        tooltipElements.link.style.display = doc.filename ? 'inline-block' : 'none'; // 根据是否有文件名显示链接

                        // Tooltip 定位逻辑 (考虑边界)
                        const containerRect = container.getBoundingClientRect();
                        // 获取当前鼠标在 SVG 内部的相对坐标
                        const [mouseX, mouseY] = d3.pointer(event, svg.node());
                        
                        // 将 SVG 坐标转换为页面坐标
                        const pageX = containerRect.left + mouseX;
                        const pageY = containerRect.top + mouseY;

                        // Tooltip 初始位置相对于鼠标
                        let tooltipX = pageX + 20;
                        let tooltipY = pageY + 20;

                        const tooltipWidth = tooltipElements.container.offsetWidth;
                        const tooltipHeight = tooltipElements.container.offsetHeight;

                        // 调整 X 轴位置，防止超出右边界
                        if (tooltipX + tooltipWidth > window.innerWidth - 20) {
                            tooltipX = pageX - tooltipWidth - 20;
                        }
                        // 调整 Y 轴位置，防止超出下边界
                        if (tooltipY + tooltipHeight > window.innerHeight - 20) {
                            tooltipY = pageY - tooltipHeight - 20;
                        }

                        tooltipElements.container.style.left = `${tooltipX}px`;
                        tooltipElements.container.style.top = `${tooltipY}px`;
                        tooltipElements.container.classList.add('active');
                    }

                    // 高亮当前节点及其直接关联的节点和链接
                    d3.select(event.currentTarget).select("circle")
                        .transition()
                        .duration(100)
                        .attr("r", d => CONFIG.d3.nodeBaseRadius + (d.degree / 4) + CONFIG.d3.nodeHighlightRadiusIncrease)
                        .attr("stroke", "#FFFFFF") // 高亮边框颜色为白色
                        .attr("stroke-width", CONFIG.d3.nodeHighlightStrokeWidth);

                    // 突出显示关联链接和节点
                    link.attr("stroke", l => l.source.id === d.id || l.target.id === d.id ? "rgba(255, 255, 255, " + CONFIG.d3.linkHighlightOpacity + ")" : "rgba(128, 128, 128, " + CONFIG.d3.linkOpacity + ")") // 关联链接更亮，其他更暗
                        .attr("stroke-width", l => l.source.id === d.id || l.target.id === d.id ? CONFIG.d3.linkHighlightStrokeWidth : CONFIG.d3.linkStrokeWidth);

                    node.select("circle")
                        .attr("opacity", n => (link.data().some(l => (l.source.id === d.id && l.target.id === n.id) || (l.target.id === d.id && l.source.id === n.id))) || n.id === d.id ? 1 : 0.3); // 非关联节点透明度降低

                })
                .on("mouseout", (event, d) => {
                    if (tooltipElements.container) {
                        tooltipElements.container.classList.remove('active');
                    }

                    // 恢复所有节点和链接的默认样式
                    d3.select(event.currentTarget).select("circle")
                        .transition()
                        .duration(200)
                        .attr("r", d => CONFIG.d3.nodeBaseRadius + (d.degree / 4))
                        .attr("stroke", d => d3.color(colors(d.category)).darker(0.5))
                        .attr("stroke-width", CONFIG.d3.nodeStrokeWidth);
                    
                    link.attr("stroke", "rgba(128, 128, 128, " + CONFIG.d3.linkOpacity + ")")
                        .attr("stroke-width", CONFIG.d3.linkStrokeWidth);

                    node.select("circle").attr("opacity", 1);
                })
                .on("click", (event, d) => {
                    const doc = documentsMap.get(d.id);
                    if (doc && doc.filename) {
                        window.open(`../data/pdfs/${doc.filename}`, '_blank');
                    }
                    event.stopPropagation(); // 防止点击节点时触发SVG的zoom事件
                });


                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.source.x + (d.target.x - d.source.x) * 0.95) // 使连线止于节点内部，避免穿出
                        .attr("y2", d => d.source.y + (d.target.y - d.source.y) * 0.95);

                    node
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });

                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }

                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }

                console.log("D3 渲染逻辑已执行完毕 (使用加载的数据)。");

                // 在数据加载和图谱渲染后，初始化PDF列表
                if (pdfListElement) {
                    pdfListElement.innerHTML = '';
                    data.documents.forEach(doc => {
                        const listItem = document.createElement('li');
                        const linkElement = document.createElement('a');
                        linkElement.href = `../data/pdfs/${doc.filename}`;
                        linkElement.target = "_blank";
                        linkElement.textContent = doc.title;
                        linkElement.title = doc.filename;
                        linkElement.dataset.nodeId = doc.id; // 存储节点ID，方便查找

                        linkElement.addEventListener('click', (event) => {
                            console.log(`点击了 PDF 列表项: ${doc.title}`);
                            event.preventDefault(); // 阻止默认的链接跳转

                            // 1. 移除所有节点的高亮
                            d3.selectAll('.node circle')
                                .transition().duration(200)
                                .attr('stroke', n => d3.color(colors(n.category)).darker(0.5))
                                .attr('stroke-width', CONFIG.d3.nodeStrokeWidth)
                                .attr('r', n => CONFIG.d3.nodeBaseRadius + (n.degree / 4))
                                .attr("opacity", 1);
                            link.attr("stroke", "rgba(128, 128, 128, " + CONFIG.d3.linkOpacity + ")")
                                .attr("stroke-width", CONFIG.d3.linkStrokeWidth);

                            // 2. 高亮对应的节点及其关联
                            const targetNodeData = graphData.nodes.find(n => n.id === doc.id);
                            if (targetNodeData) {
                                const targetNodeSelection = d3.select(svgElement).select(`.node circle[data-id="${doc.id}"]`);
                                if (!targetNodeSelection.empty()) {
                                    const parentG = d3.select(targetNodeSelection.node().parentNode); // 获取父<g>元素

                                    parentG.select("circle")
                                        .transition()
                                        .duration(100)
                                        .attr("r", n => CONFIG.d3.nodeBaseRadius + (n.degree / 4) + CONFIG.d3.nodeHighlightRadiusIncrease)
                                        .attr("stroke", "#FFFFFF")
                                        .attr("stroke-width", CONFIG.d3.nodeHighlightStrokeWidth);
                                    
                                    link.attr("stroke", l => l.source.id === doc.id || l.target.id === doc.id ? "rgba(255, 255, 255, " + CONFIG.d3.linkHighlightOpacity + ")" : "rgba(128, 128, 128, " + CONFIG.d3.linkOpacity + ")")
                                        .attr("stroke-width", l => l.source.id === doc.id || l.target.id === doc.id ? CONFIG.d3.linkHighlightStrokeWidth : CONFIG.d3.linkStrokeWidth);

                                    node.select("circle").attr("opacity", n => (link.data().some(l => (l.source.id === doc.id && l.target.id === n.id) || (l.target.id === doc.id && l.source.id === n.id))) || n.id === doc.id ? 1 : 0.3);


                                    // 3. 将视图平移到高亮节点
                                    const currentTransform = d3.zoomTransform(svg.node());
                                    const centerX = width / 2;
                                    const centerY = height / 2;
                                    const newX = centerX - targetNodeData.x * currentTransform.k;
                                    const newY = centerY - targetNodeData.y * currentTransform.k;
                                    svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(newX, newY).scale(currentTransform.k));
                                    
                                } else {
                                    console.warn(`未找到与文档 ID "${doc.id}" 对应的图谱节点元素进行高亮。`);
                                }
                            } else {
                                console.warn(`未找到与文档 ID "${doc.id}" 对应的图谱节点数据进行高亮。`);
                            }
                            
                            // 4. 实际打开PDF
                            if (doc.filename) {
                                window.open(`../data/pdfs/${doc.filename}`, '_blank');
                            } else {
                                console.warn(`文档 "${doc.title}" 没有关联的PDF文件名。`);
                            }
                        });

                        listItem.appendChild(linkElement);
                        pdfListElement.appendChild(listItem);
                    });
                    console.log("PDF 列表填充完成，并添加了点击事件。");
                }


            })
            .catch(error => {
                console.error("加载 processed_data.json 或渲染图谱时发生错误:", error);
                alert("加载知识图谱数据失败，请检查 'data/processed_data.json' 文件是否存在且格式正确。\n错误详情请查看浏览器控制台。");
            });
    });
</script>
</body>
</html>
